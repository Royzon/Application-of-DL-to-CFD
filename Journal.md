### @2019-1-2
#### OpenFOAM Structure
![img](/img/OpenFOAM-structure.png)

![folder structure](/img/foamFolderStructure.png)

reference: http://www.cfdyna.com/Home/OpenFOAM.html

### @2018-12-15
#### How to install OpenFOAM on Arch linux
1. Enable the Loop Module

check:
```shell
# lsmod | grep loop
```
If the loop module doesn't loaded, run the code below:
```shell
# tee /etc/modules-load.d/loop.conf <<< "loop"
# modprobe loop
```

2. Install Docker
```shell
# pacman -S docker
```

3. start/enable/stop Docker
```shell
# systemctl start docker.service
 
# systemctl enable docker.service

# systemctl stop docker.service
```
Then we check the docker info with
```shell
# docker info
```

4. Grand user with docker group
```shell
# groupadd docker
 
# gpasswd -a user docker [replace user with your username]
``` 

5. Download OpenFoam scripts to load and run OpenFoam
* Download two scripts
[installOpenFOAM](https://sourceforge.net/projects/openfoamplus/files/v1806/installOpenFOAM)
[startOpenFOAM](https://sourceforge.net/projects/openfoamplus/files/v1806/startOpenFOAM)

* Make two scripts executable
```shell
chmod +x installOpenFOAM 
chmod +x startOpenFOAM 
```

* Run install script
```shell
./installOpenFOAM
```

* Run start script
```shell
./startOpenFOAM
```

6. Test
```shell
mkdir -p $FOAM_RUN 
run 
cp -r $FOAM_TUTORIALS/incompressible/icoFoam/cavity/cavity . 
cd cavity 
blockMesh 
icoFoam 
```
7. Copy tutorial
``` shell
mkdir -p $FOAM_RUN 
cp -r $FOAM_TUTORIALS $FOAM_RUN
```
### @2018-12-20
#### How blockMesh works
1. where is mesh?
Mesh is generated by `blockMeshDict` located in the `system` folder, which decompose the domain geometry into a set of 1 or more three dimesional, hexahedral blocks. Each block is defined by 8 vertices(less than 8 vertices is possible).

#### Block coordinate system
1. It is a [right-handed](https://www.evl.uic.edu/ralph/508S98/coordinates.html).
2. Order to write the vertices
    * vertex 0
    * Move 0 to 1 by x axis
    * Move 1 to 2 by y axis
    * 0,1,2,3 define a plane
    * then 4,5,6,7 define other planes.

#### Meaning of blockMeshDict

* scale: scaling factor. eg. 0.001=mm, 1=meter
* vertice: list of vertex in 3D
* edges: arc or spline edges. 
    * edge type: arc, spline, polyline,BSpline,line(default)
    * eg. arc 1 5 (1.1 0.0 0.5) connect the vertex 1 and 5 with interpolation point(1.1 0.0 0.5)
* block: ordered list of vertex labels and mesh size. eg. `hex (0 1 2 3 4 5 6 7) (20 20 1) simpleGrading (1 1 1)` means vertex 0 to 7 to form a block, (20 20 1) defines numbers of cells in the order of x1,x2,x3. The last part `simpleGrading (1 1 1)` is cell expansion ratios, which is length of last block divded by the first one. More advanced information we can refer to `edgeGrading` and `multi-grading` to set up expansion ratios for each edge.
``` c
blocks
(
hex (0 1 2 3 4 5 6 7) (100 300 100)
simpleGrading
(
1 // x-direction expansion ratio
(
(0.2 0.3 4) // 20% y-dir, 30% cells, expansion = 4
(0.6 0.4 1) // 60% y-dir, 40% cells, expansion = 1
(0.2 0.3 0.25) // 20% y-dir, 30% cells, expansion = 0.25 (1/4)
)
3 // z-direction expansion ratio
)
);
```
* boundary: boundary is broken into patches. Each patche has its name, type and faces. 
``` c
boundary
(
    movingWall  // patch name
    {
        type wall; // patch type
        faces
        (
            //looking from inside the block and starting with any vertex, the
 face must be traversed in a clockwise direction 
            (3 7 6 2)  
        );
    }
  .........  
);
```
* mergePatchpairs:used in face merging.`need to be fulfilled`

#### Initial conditions
Once setting up the mesh, we can run `blockMesh` under project folder, and get the inital status files(p and U) in a 0 sub-folder. Let's see the content of p:
``` c
// dimensinSet is 7 scalars delimited by square brackets, here is m^2s^{-2} to get kinematic pressure
dimensions      [0 2 -2 0 0 0 0];

internalField   uniform 0;

boundaryField
{
    movingWall
    {
        // the normal gradient of pressure is 0
        type            zeroGradient;
    }

    fixedWalls
    {
        type            zeroGradient;
    }

    frontAndBack
    {
        type            empty;
    }
}

```

